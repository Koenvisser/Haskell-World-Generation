<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Utils</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">Haskell-World-Generation-0.1.0.0</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/Utils.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Utils</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains utility functions and data structures that can be used to define rules
   in an easier way. Also contains functions that can be used to create shapes that can be used
   in the rules, and a function that can be used to create a simple material map for all sides.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:listToShape">listToShape</a> :: [<a href="Internal-Def.html#t:Pos" title="Internal.Def">Pos</a>] -&gt; <a href="Def.html#t:Shape" title="Def">Shape</a></li><li class="src short"><a href="#v:allNeighbours">allNeighbours</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a></li><li class="src short"><a href="#v:directNeighbours">directNeighbours</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a></li><li class="src short"><a href="#v:leftNeighbour">leftNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a></li><li class="src short"><a href="#v:rightNeighbour">rightNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a></li><li class="src short"><a href="#v:downNeighbour">downNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a></li><li class="src short"><a href="#v:upNeighbour">upNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a></li><li class="src short"><a href="#v:aboveNeighbour">aboveNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a></li><li class="src short"><a href="#v:belowNeighbour">belowNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a></li><li class="src short"><a href="#v:nextToAny">nextToAny</a> :: [<a href="Internal-Def.html#t:Tile" title="Internal.Def">Tile</a>] -&gt; <a href="Def.html#t:Shape" title="Def">Shape</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a></li><li class="src short"><a href="#v:nextToAll">nextToAll</a> :: [<a href="Internal-Def.html#t:Tile" title="Internal.Def">Tile</a>] -&gt; <a href="Def.html#t:Shape" title="Def">Shape</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a></li><li class="src short"><a href="#v:allMustBe">allMustBe</a> :: [<a href="Internal-Def.html#t:Tile" title="Internal.Def">Tile</a>] -&gt; <a href="Def.html#t:Shape" title="Def">Shape</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a></li><li class="src short"><a href="#v:anyRule">anyRule</a> :: (a -&gt; <a href="Internal-Def.html#t:RuleMonad" title="Internal.Def">RuleMonad</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="Internal-Def.html#t:RuleMonad" title="Internal.Def">RuleMonad</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:allRule">allRule</a> :: (a -&gt; <a href="Internal-Def.html#t:RuleMonad" title="Internal.Def">RuleMonad</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="Internal-Def.html#t:RuleMonad" title="Internal.Def">RuleMonad</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:weightedRule">weightedRule</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a></li><li class="src short"><a href="#v:maxRelativeHeight">maxRelativeHeight</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a></li><li class="src short"><a href="#v:minRelativeHeight">minRelativeHeight</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a></li><li class="src short"><a href="#v:isInPos">isInPos</a> :: [<a href="Internal-Def.html#t:Pos" title="Internal.Def">Pos</a>] -&gt; <a href="Internal-Def.html#t:Pos" title="Internal.Def">Pos</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:canExistAt">canExistAt</a> :: (<a href="Internal-Def.html#t:Pos" title="Internal.Def">Pos</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a></li><li class="src short"><a href="#v:createMaterialMapForAllSides">createMaterialMapForAllSides</a> :: <a href="Internal-Def.html#t:Material" title="Internal.Def">Material</a> -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="Internal-Def.html#t:Side" title="Internal.Def">Side</a> <a href="Internal-Def.html#t:Material" title="Internal.Def">Material</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:listToShape" class="def">listToShape</a> :: [<a href="Internal-Def.html#t:Pos" title="Internal.Def">Pos</a>] -&gt; <a href="Def.html#t:Shape" title="Def">Shape</a> <a href="src/Utils.html#listToShape" class="link">Source</a> <a href="#v:listToShape" class="selflink">#</a></p><div class="doc"><p>Convert a list of relative positions into a shape that takes a position and returns
   the absolute positions of the shape at that position</p></div></div><div class="top"><p class="src"><a id="v:allNeighbours" class="def">allNeighbours</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a> <a href="src/Utils.html#allNeighbours" class="link">Source</a> <a href="#v:allNeighbours" class="selflink">#</a></p><div class="doc"><p>A shape that contains all the direct horizontal, vertical and diagonal neighbours of a position</p></div></div><div class="top"><p class="src"><a id="v:directNeighbours" class="def">directNeighbours</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a> <a href="src/Utils.html#directNeighbours" class="link">Source</a> <a href="#v:directNeighbours" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:leftNeighbour" class="def">leftNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a> <a href="src/Utils.html#leftNeighbour" class="link">Source</a> <a href="#v:leftNeighbour" class="selflink">#</a></p><div class="doc"><p>A shape that contains the neighbour to the left of a position</p></div></div><div class="top"><p class="src"><a id="v:rightNeighbour" class="def">rightNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a> <a href="src/Utils.html#rightNeighbour" class="link">Source</a> <a href="#v:rightNeighbour" class="selflink">#</a></p><div class="doc"><p>A shape that contains the neighbour to the right of a position</p></div></div><div class="top"><p class="src"><a id="v:downNeighbour" class="def">downNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a> <a href="src/Utils.html#downNeighbour" class="link">Source</a> <a href="#v:downNeighbour" class="selflink">#</a></p><div class="doc"><p>A shape that contains the neighbour to the front of a position</p></div></div><div class="top"><p class="src"><a id="v:upNeighbour" class="def">upNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a> <a href="src/Utils.html#upNeighbour" class="link">Source</a> <a href="#v:upNeighbour" class="selflink">#</a></p><div class="doc"><p>A shape that contains the neighbour to the back of a position</p></div></div><div class="top"><p class="src"><a id="v:aboveNeighbour" class="def">aboveNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a> <a href="src/Utils.html#aboveNeighbour" class="link">Source</a> <a href="#v:aboveNeighbour" class="selflink">#</a></p><div class="doc"><p>A shape that contains the neighbour above a position</p></div></div><div class="top"><p class="src"><a id="v:belowNeighbour" class="def">belowNeighbour</a> :: <a href="Def.html#t:Shape" title="Def">Shape</a> <a href="src/Utils.html#belowNeighbour" class="link">Source</a> <a href="#v:belowNeighbour" class="selflink">#</a></p><div class="doc"><p>A shape that contains the neighbour below a position</p></div></div><div class="top"><p class="src"><a id="v:nextToAny" class="def">nextToAny</a> :: [<a href="Internal-Def.html#t:Tile" title="Internal.Def">Tile</a>] -&gt; <a href="Def.html#t:Shape" title="Def">Shape</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a> <a href="src/Utils.html#nextToAny" class="link">Source</a> <a href="#v:nextToAny" class="selflink">#</a></p><div class="doc"><p>A rule that takes a list of tiles and a shape, and returns True if any of the tiles defined in the list
   tile are within the shape at the given position. </p></div></div><div class="top"><p class="src"><a id="v:nextToAll" class="def">nextToAll</a> :: [<a href="Internal-Def.html#t:Tile" title="Internal.Def">Tile</a>] -&gt; <a href="Def.html#t:Shape" title="Def">Shape</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a> <a href="src/Utils.html#nextToAll" class="link">Source</a> <a href="#v:nextToAll" class="selflink">#</a></p><div class="doc"><p>A rule that takes a list of tiles and a shape, and returns True if all of the tiles defined in the list
   tile are within the shape at the given position. </p></div></div><div class="top"><p class="src"><a id="v:allMustBe" class="def">allMustBe</a> :: [<a href="Internal-Def.html#t:Tile" title="Internal.Def">Tile</a>] -&gt; <a href="Def.html#t:Shape" title="Def">Shape</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a> <a href="src/Utils.html#allMustBe" class="link">Source</a> <a href="#v:allMustBe" class="selflink">#</a></p><div class="doc"><p>A rule that takes a list of tiles and a shape, and returns True if all of the tiles in the shape are 
   within the list of tiles at the given position. The boolean parameter determines if an empty tile 
   should be considered a match.</p></div></div><div class="top"><p class="src"><a id="v:anyRule" class="def">anyRule</a> :: (a -&gt; <a href="Internal-Def.html#t:RuleMonad" title="Internal.Def">RuleMonad</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="Internal-Def.html#t:RuleMonad" title="Internal.Def">RuleMonad</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Utils.html#anyRule" class="link">Source</a> <a href="#v:anyRule" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:allRule" class="def">allRule</a> :: (a -&gt; <a href="Internal-Def.html#t:RuleMonad" title="Internal.Def">RuleMonad</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="Internal-Def.html#t:RuleMonad" title="Internal.Def">RuleMonad</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Utils.html#allRule" class="link">Source</a> <a href="#v:allRule" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:weightedRule" class="def">weightedRule</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a> <a href="src/Utils.html#weightedRule" class="link">Source</a> <a href="#v:weightedRule" class="selflink">#</a></p><div class="doc"><p>A rule that takes a float f and returns a rule with chance f of returning True </p></div></div><div class="top"><p class="src"><a id="v:maxRelativeHeight" class="def">maxRelativeHeight</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a> <a href="src/Utils.html#maxRelativeHeight" class="link">Source</a> <a href="#v:maxRelativeHeight" class="selflink">#</a></p><div class="doc"><p>A rule that checks if the position has a height of at most p times the height of the tileMap</p></div></div><div class="top"><p class="src"><a id="v:minRelativeHeight" class="def">minRelativeHeight</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a> <a href="src/Utils.html#minRelativeHeight" class="link">Source</a> <a href="#v:minRelativeHeight" class="selflink">#</a></p><div class="doc"><p>A rule that checks if the position has a height of at least p times the height of the tileMap</p></div></div><div class="top"><p class="src"><a id="v:isInPos" class="def">isInPos</a> :: [<a href="Internal-Def.html#t:Pos" title="Internal.Def">Pos</a>] -&gt; <a href="Internal-Def.html#t:Pos" title="Internal.Def">Pos</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Utils.html#isInPos" class="link">Source</a> <a href="#v:isInPos" class="selflink">#</a></p><div class="doc"><p>A function that takes a list of positions and returns a function that checks if a position is in the list</p></div></div><div class="top"><p class="src"><a id="v:canExistAt" class="def">canExistAt</a> :: (<a href="Internal-Def.html#t:Pos" title="Internal.Def">Pos</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Internal-Def.html#t:Rule" title="Internal.Def">Rule</a> <a href="src/Utils.html#canExistAt" class="link">Source</a> <a href="#v:canExistAt" class="selflink">#</a></p><div class="doc"><p>A rule that takes a function that takes a position and returns a boolean, and returns a rule using this function</p></div></div><div class="top"><p class="src"><a id="v:createMaterialMapForAllSides" class="def">createMaterialMapForAllSides</a> :: <a href="Internal-Def.html#t:Material" title="Internal.Def">Material</a> -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="Internal-Def.html#t:Side" title="Internal.Def">Side</a> <a href="Internal-Def.html#t:Material" title="Internal.Def">Material</a> <a href="src/Utils.html#createMaterialMapForAllSides" class="link">Source</a> <a href="#v:createMaterialMapForAllSides" class="selflink">#</a></p><div class="doc"><p>A function that takes a material and returns a map from all sides to that material</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.28.0</p></div></body></html>